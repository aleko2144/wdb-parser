# import struct
import struct
import sys
import argparse
import os
	
def printw(file, string):
	print(string)
	file.write(string + '\n')
	
def read_string_ht3(file):
	byte = b'\x10'
	counter = 0
	
	ret = "none"
		
	pos_start = file.tell()
		
	while byte != b'\x00':
		
		byte = file.read(1)
		counter += 1;
			
		if counter > 256:
			break
						
	file.seek(pos_start, 0)
						
	ret = str(file.read(counter).decode("utf-8")).rstrip('\0')
	
	return ret

#116 - space (double matrix 3x3, position)
		

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument ('name', nargs='?')
	namespace = parser.parse_args()
	
	input_file = namespace.name
	#output_dir = namespace.name[:-4] + "\\"
	output_meshes_dir = namespace.name[:-4] + "\\meshes\\"
	output_spaces_dir = namespace.name[:-4] + "\\spaces\\"
	
	os.makedirs('{}'.format(namespace.name[:-4]), exist_ok=True)
	os.makedirs('{}'.format(output_meshes_dir), exist_ok=True)
	os.makedirs('{}'.format(output_spaces_dir), exist_ok=True)

	output_file = (namespace.name[:-4] + "\\" + "output.txt")
	
	#out_file = open('output.txt','w')
	#printw(out_file, str(namespace.name))

	with open (input_file,'r+b') as file:
		out_file = open(output_file,'w')
		
		printw(out_file, "generated by wdb-parser")
		printw(out_file, "by vk.com/rnr_mods")
		printw(out_file, "\n")
		
		file.seek(156, 1) #WDB, type 406, ещё что-нибудь
		type = struct.unpack("<i",file.read(4))[0]
		
		sections_def = []
		sections = []
		
		printw(out_file, "wdb file blocks (def)")
		
		if (type == 407):
			section_length = struct.unpack("<i",file.read(4))[0]
			file.seek(8, 1) # Default
			names_count = struct.unpack("<i",file.read(4))[0]
			
			for i in range(names_count):
				section_type = struct.unpack("<i",file.read(4))[0]
				section_addr = struct.unpack("<i",file.read(4))[0]
				section_name_addr = struct.unpack("<i",file.read(4))[0]
				
				current_offset = file.tell();	
				file.seek(section_name_addr, 0)		
				block_name = read_string_ht3(file)
				
				file.seek(section_addr, 0)
				real_type = struct.unpack("<i",file.read(4))[0]
				block_length = struct.unpack("<i",file.read(4))[0]
				file.seek(current_offset, 0)
				
				printw(out_file,'type: '+str(section_type))
				printw(out_file,'real type: '+str(real_type))
				printw(out_file,'block_length: '+str(block_length))
				printw(out_file,'offset: '+str(section_addr))
				printw(out_file,'name offset: '+str(section_name_addr))
				printw(out_file,'name: '+ block_name)
				printw(out_file, '\n')
				
				
				sections.append( (section_type, section_addr, section_name_addr, block_name, len(block_name) + 1, real_type) )
				
		printw(out_file, "")
				
		for i in range(len(sections)):
			#section[0] - block type
			#section[1] - offset
			#section[2] - name offset
			#section[3] - name
			#section[4] - name length
			#section[5] - real type (не то, что в начале файла, а то, что действительно записано по смещению)
			#видимо, тип, указанный в section[0] - и есть настоящий тип, а section[5] - подтип, разновидность блока
			
			if sections[i][5] == 116:
				name = ""
				
				if (len(sections[i][3]) > 0):
					name = sections[i][3]
				else:
					name = ("Untitled_" + str(sections[i][1]))
			
				output_obj = open((output_spaces_dir + name + ".obj"),'w')
				printw(out_file, "SimpleSpaceData (116), position " + str(hex(sections[i][1])) + ", name=" + name)
				output_obj.write("# SimpleSpaceData (116), position " + str(hex(sections[i][1])) + '\n')
				output_obj.write('\n')
				
				output_obj.write("o " + name + '\n')
				output_obj.write('\n')
				
				file.seek(sections[i][1] + 4, 0) #к блоку 
				
				file.seek(12, 1)
				file.seek(sections[i][4], 1) #skip name
				file.seek(32, 1)

				m0_0 = struct.unpack('<d',file.read(8))[0]
				m0_1 = struct.unpack('<d',file.read(8))[0]
				m0_2 = struct.unpack('<d',file.read(8))[0]
				
				m1_0 = struct.unpack('<d',file.read(8))[0]
				m1_1 = struct.unpack('<d',file.read(8))[0]
				m1_2 = struct.unpack('<d',file.read(8))[0]
				
				m2_0 = struct.unpack('<d',file.read(8))[0]
				m2_1 = struct.unpack('<d',file.read(8))[0]
				m2_2 = struct.unpack('<d',file.read(8))[0]
				
				x = struct.unpack('<d',file.read(8))[0]
				y = struct.unpack('<d',file.read(8))[0]
				z = struct.unpack('<d',file.read(8))[0]
				
				output_obj.write(f"# {m0_0} {m0_1} {m0_2}" + '\n')
				output_obj.write(f"# {m1_0} {m1_1} {m1_2}" + '\n')
				output_obj.write(f"# {m2_0} {m2_1} {m2_2}" + '\n')
				
				output_obj.write(f"v {x} {y} {z}" + '\n')
				
				output_obj.write('\n')				
			
			if sections[i][5] == 309 or sections[i][5] == 310: #312, указанный в начале файла, обычно равен 309
				name = ""
				
				if (len(sections[i][3]) > 0):
					name = sections[i][3]
				else:
					name = ("Untitled_" + str(sections[i][1]))
			
				output_obj = open((output_meshes_dir + name + ".obj"),'w')
				#output_debug_obj = open((output_meshes_dir + name + "_debug.obj"),'w')
				
				file.seek(sections[i][1] + 4, 0) #к блоку
				
				block_length = struct.unpack("<i",file.read(4))[0]
				
				file.seek(sections[i][4], 1) #skip name
				
				verts_type = struct.unpack("<i",file.read(4))[0]
				
				vertices_len = struct.unpack('<i',file.read(4))[0]
				
				vertices = []
				vert_normals = []
				uvs = []
				
				#print(str(vertices_len))
				#print(str(file.tell()))
				
				if (vertices_len > 999990):
					printw(out_file, "Vertices num is too big. Check position " + str(hex(file.tell())) + ".")
					input("Press ENTER key to exit.")
					sys.exit(0)
				else:
					if (sections[i][5] == 309):
						printw(out_file, "ContainerVertex (309), vertex_flags=" + str(verts_type) + ", num=" + str(vertices_len) + ", position=" + str(hex(sections[i][1])) + ", name=" + name)
						output_obj.write("# ContainerVertex (309), vertex_flags=" + str(verts_type) + ", num=" + str(vertices_len) + ", position=" + str(hex(sections[i][1])) + '\n')
					elif (sections[i][5] == 310):
						printw(out_file, "ContainerVertexDynamic (310), vertex_flags=" + str(verts_type) + ", num=" + str(vertices_len) + ", position=" + str(hex(sections[i][1])) + ", name=" + name)
						output_obj.write("# ContainerVertexDynamic (310), vertex_flags=" + str(verts_type) + ", num=" + str(vertices_len) + ", position=" + str(hex(sections[i][1])) + '\n')
					
					output_obj.write("o " + name + '\n')
					output_obj.write('\n')
					
					if (verts_type == 274):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 338):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							
							diffuse1 = 0
							diffuse2 = 0
							diffuse3 = 0
							diffuse4 = 0
							
							diffuse1_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse2_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse3_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse4_int = int.from_bytes((file.read(1)), byteorder="big")
							
							if (diffuse1_int == 1):
								diffuse1 = 1
								
							if (diffuse2_int == 1):
								diffuse2 = 1
								
							if (diffuse3_int == 1):
								diffuse3 = 1
								
							if (diffuse4_int == 1):
								diffuse4 = 1
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							uvs.append((u, 1 - v))							
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')
							output_obj.write(f"# DIFFUSE ({diffuse1} {diffuse2} {diffuse3} {diffuse4})")
							output_obj.write('\n')							
					elif (verts_type == 514):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							uvs.append((u, 1 - v))
							
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 530):	
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 594):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							file.seek(4, 1)
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
				
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 786):	
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(16, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 1042):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(24, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')														
					elif (verts_type == 4370):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							bindex = struct.unpack('<i', file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')			
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')						
					elif (verts_type == 4374):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							blend = struct.unpack('<f',file.read(4))[0]
							bindex = struct.unpack('<i', file.read(4))[0]

							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
	
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')	
							output_obj.write(f"# blend={blend}")
							output_obj.write('\n')							
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')							
					elif (verts_type == 4434):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							bindex = struct.unpack('<i', file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							vert_normals.append((nx, ny, nz))
							
							diffuse1 = 0
							diffuse2 = 0
							diffuse3 = 0
							diffuse4 = 0
							
							diffuse1_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse2_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse3_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse4_int = int.from_bytes((file.read(1)), byteorder="big")
							
							if (diffuse1_int == 1):
								diffuse1 = 1
								
							if (diffuse2_int == 1):
								diffuse2 = 1
								
							if (diffuse3_int == 1):
								diffuse3 = 1
								
							if (diffuse4_int == 1):
								diffuse4 = 1
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')	
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')
							output_obj.write(f"# DIFFUSE ({diffuse1} {diffuse2} {diffuse3} {diffuse4})")
							output_obj.write('\n')	
					elif (verts_type == 4626):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							

							
							bindex = struct.unpack('<i', file.read(4))[0]

							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							#v8 = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')		
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')					
					elif (verts_type == 4882):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							file.seek(4, 1)
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							u2 = struct.unpack('<f',file.read(4))[0]
							v2 = struct.unpack('<f',file.read(4))[0]
							
							u3 = struct.unpack('<f',file.read(4))[0]
							v3 = struct.unpack('<f',file.read(4))[0]
							#v8 = struct.unpack('<f',file.read(4))[0]
							
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')												
					elif (verts_type == 5202):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							bindex = struct.unpack('<i',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							diffuse1 = 0
							diffuse2 = 0
							diffuse3 = 0
							diffuse4 = 0
							
							diffuse1_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse2_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse3_int = int.from_bytes((file.read(1)), byteorder="big")
							diffuse4_int = int.from_bytes((file.read(1)), byteorder="big")
							
							if (diffuse1_int == 1):
								diffuse1 = 1
								
							if (diffuse2_int == 1):
								diffuse2 = 1
								
							if (diffuse3_int == 1):
								diffuse3 = 1
								
							if (diffuse4_int == 1):
								diffuse4 = 1
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							
							u2 = struct.unpack('<f',file.read(4))[0]
							v2 = struct.unpack('<f',file.read(4))[0]
							
							u3 = struct.unpack('<f',file.read(4))[0]
							v3 = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')
							output_obj.write(f"# DIFFUSE ({diffuse1} {diffuse2} {diffuse3} {diffuse4})")
							output_obj.write('\n')	
					elif (verts_type == 8466):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(24, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 8530):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							file.seek(4, 1)
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(12, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 8722):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(20, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')													
					elif (verts_type == 3416834):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							file.seek(4, 1)
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							file.seek(12, 1)
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')														
					elif (verts_type == 3420930): #4882
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							file.seek(4, 1)
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							u2 = struct.unpack('<f',file.read(4))[0]
							v2 = struct.unpack('<f',file.read(4))[0]
							
							u3 = struct.unpack('<f',file.read(4))[0]
							v3 = struct.unpack('<f',file.read(4))[0]
							#v8 = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')													
					elif (verts_type == 5506066):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							uvs.append((u, 1 - v))
							
							file.seek(36, 1)
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')						
					elif (verts_type == 5510162):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							var_int = struct.unpack('<i',file.read(4))[0] #номер плоскости?
							#file.seek(4, 1) #int
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]
							nz = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							uvs.append((u, 1 - v))
							
							file.seek(36, 1)

							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')								
					elif (verts_type == 5510166):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							blend = struct.unpack('<f',file.read(4))[0]
							bindex = struct.unpack('<i', file.read(4))[0]

							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							u1 = struct.unpack('<f',file.read(4))[0]
							v1 = struct.unpack('<f',file.read(4))[0]
							w1 = struct.unpack('<f',file.read(4))[0]
							
							u2 = struct.unpack('<f',file.read(4))[0]
							v2 = struct.unpack('<f',file.read(4))[0]
							w2 = struct.unpack('<f',file.read(4))[0]
							
							u3 = struct.unpack('<f',file.read(4))[0]
							v3 = struct.unpack('<f',file.read(4))[0]
							w3 = struct.unpack('<f',file.read(4))[0]
	
							uvs.append((u, 1 - v))
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')	
							output_obj.write(f"# blend={blend}")
							output_obj.write('\n')							
							output_obj.write(f"# BINDEX={bindex}")
							output_obj.write('\n')			
					elif (verts_type == 22021394):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							file.seek(8, 1) #uv1
							file.seek(8, 1) #uv2
							file.seek(8, 1) #uv3
							file.seek(8, 1) #uv4
							file.seek(8, 1) #uv5
							
							file.seek(4, 1)
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')							
					elif (verts_type == 22025490):
						for i in range(vertices_len):
						
							x = struct.unpack('<f',file.read(4))[0]
							y = struct.unpack('<f',file.read(4))[0]
							z = struct.unpack('<f',file.read(4))[0]
							
							nx = struct.unpack('<f',file.read(4))[0]
							ny = struct.unpack('<f',file.read(4))[0]					
							nz = struct.unpack('<f',file.read(4))[0]
							
							u = struct.unpack('<f',file.read(4))[0]
							v = struct.unpack('<f',file.read(4))[0]
							
							vert_normals.append((nx, ny, nz))
							uvs.append((u, 1 - v))
							
							file.seek(8, 1) #uv1
							file.seek(8, 1) #uv2
							file.seek(8, 1) #uv3
							file.seek(8, 1) #uv4
							file.seek(8, 1) #uv5
							file.seek(8, 1) #uv6
							
							output_obj.write(f"v {round(x, 6)} {round(y, 6)} {round(z, 6)}")
							output_obj.write('\n')								
					else:
						printw(out_file, "Unknown verts type: " + str(verts_type))
						printw(out_file, "Verts length (counted): " + str(int((block_length - 16 - sections[i][4]) / vertices_len)))
						input("Press ENTER key to exit.")
						sys.exit(0)
					
					for i in range(len(uvs)):
						output_obj.write(f"vt {round(uvs[i][0], 6)} {round(uvs[i][1], 6)}")
						output_obj.write('\n')
							
					for i in range(len(vert_normals)):
						output_obj.write(f"vn {round(vert_normals[i][0], 6)} {round(vert_normals[i][1], 6)} {round(vert_normals[i][2], 6)}")
						output_obj.write('\n')
						
						
				mesh_type = struct.unpack("<i",file.read(4))[0]
				
				#print("type: " + str(mesh_type))
				mesh_section_length = struct.unpack("<i",file.read(4))[0]
				file.seek(1, 1)
				faces_type = struct.unpack("<i",file.read(4))[0]
				
				#faces_count = 0
				
				#if (fc_1 == 73084):
				#	faces_count = 55
				#else:
				#	faces_count  = struct.unpack("<i",file.read(4))[0]
				
				faces_count = struct.unpack("<i",file.read(4))[0]
				
				if (mesh_type == 312):
					printw(out_file, "ContainerIndex (312), index_flags=" + str(faces_type) + ", num=" + str(faces_count) + ", position=" + str(hex(file.tell())))
					output_obj.write("\n" + "# ContainerIndex (312), index_flags=" + str(faces_type) + ", num=" + str(faces_count) + ", position=" + str(hex(file.tell())))
				elif (mesh_type == 313):
					printw(out_file, "ContainerIndexDynamic (313), index_flags=" + str(faces_type) + ", num=" + str(faces_count) + ", position=" + str(hex(file.tell())))
					output_obj.write("\n" + "# ContainerIndexDynamic (313), index_flags=" + str(faces_type) + ", num=" + str(faces_count) + ", position=" + str(hex(file.tell())))
				output_obj.write("\n" + "s 1")
				
				if (faces_count > 256000):
					printw(out_file, "Faces num is too big. Check position " + str(hex(file.tell())) + ".")
					input("Press ENTER key to exit.")
					sys.exit(0)
				else:	
					output_obj.write('\n')
					if (mesh_type == 312):
						for i in range(int(faces_count / 3)):
							f1_r = struct.unpack("<H",file.read(2))[0]
							f2_r = struct.unpack("<H",file.read(2))[0]
							f3_r = struct.unpack("<H",file.read(2))[0]
										
							f1 = 0
							f2 = 0
							f3 = 0
								
							to_print_f1 = ""
							to_print_f2 = ""
							to_print_f3 = ""
										
							if (f1_r + 1 < vertices_len):
								f1 = f1_r + 1
								to_print_f1 = str(f1)
							else:
								f1 = -1
								to_print_f1 = ""
											
							if (f2_r + 1 < vertices_len):
								f2 = f2_r + 1
								to_print_f2 = str(f2)
							else:
								f2 = -1
								to_print_f2 = ""
												
							if (f3_r + 1 < vertices_len):
								f3 = f3_r + 1
								to_print_f3 = str(f3)
							else:
								f3 = -1
								to_print_f3 = ""
								
							if (to_print_f1 != "" or to_print_f2 != "" or to_print_f3 != ""):
								output_obj.write("f ")
								
								if (to_print_f1 != ""):
									output_obj.write(to_print_f1 + "/" + to_print_f1 + "/" + to_print_f1 + " ")
									
								if (to_print_f2 != ""):
									output_obj.write(to_print_f2 + "/" + to_print_f2 + "/" + to_print_f2 + " ")
								
								if (to_print_f3 != ""):
									output_obj.write(to_print_f3 + "/" + to_print_f3 + "/" + to_print_f3)
			
								output_obj.write('\n')

					elif (mesh_type == 313): #needs to be fixed
						for i in range(int(faces_count / 3)):
							
							f1_r = struct.unpack("<H",file.read(2))[0]
							f2_r = struct.unpack("<H",file.read(2))[0]
							f3_r = struct.unpack("<H",file.read(2))[0]
								
							f1 = 0
							f2 = 0
							f3 = 0
								
							if (f1_r + 2 < vertices_len):
								f1 = f1_r + 1
							else:
								f1 = -1
									
							if (f2_r + 2 < vertices_len):
								f2 = f2_r + 1
							else:
								f2 = -1
									
							if (f3_r + 2 < vertices_len):
								f3 = f3_r + 1
							else:
								f3 = -1
								
								
							output_obj.write(f"f {f1}/{f1} {f2}/{f2} {f3}/{f3}")
							output_obj.write('\n')
							
		print("EOF")
							# f1_r = struct.unpack("<H",file.read(2))[0]
							# f2_r = struct.unpack("<H",file.read(2))[0]
							# f3_r = struct.unpack("<H",file.read(2))[0]
							
							# f1 = 0
							# f2 = 0
							# f3 = 0
							
							# if (f1_r + 2 < vertices_len):
								# f1 = f1_r + 1
							# else:
								# f1 = 1
								
							# if (f2_r + 2 < vertices_len):
								# f2 = f2_r + 1
							# else:
								# f2 = 1
								
							# if (f3_r + 2 < vertices_len):
								# f3 = f3_r + 1
							# else:
								# f3 = 1
							
							
							# printw(output_obj, f"f {f1}/{f1}/{f1} {f2}/{f2}/{f2} {f3}/{f3}/{f3}")
						
								
						# else:
							# for i in range(int(faces_count / 3)):
								
								# f1_r = struct.unpack("<H",file.read(2))[0]
								# f2_r = struct.unpack("<H",file.read(2))[0]
								# f3_r = struct.unpack("<H",file.read(2))[0]
										
								# f1 = 0
								# f2 = 0
								# f3 = 0
								
								# to_print_f1 = ""
								# to_print_f2 = ""
								# to_print_f3 = ""
										
								# if (f1_r + 2 < vertices_len):
									# f1 = f1_r + 1
									# to_print_f1 = str(f1)
								# else:
									# f1 = -1
									# to_print_f1 = ""
											
								# if (f2_r + 2 < vertices_len):
									# f2 = f2_r + 1
									# to_print_f2 = str(f2)
								# else:
									# f2 = -1
									# to_print_f2 = ""
											
								# if (f3_r + 2 < vertices_len):
									# f3 = f3_r + 1
									# to_print_f3 = str(f3)
								# else:
									# f3 = -1
									# to_print_f3 = ""
									
								# if (to_print_f1 != "" or to_print_f2 != "" or to_print_f3 != ""):
									# output_obj.write("f ")
									
									# if (to_print_f1 != ""):
										# output_obj.write(to_print_f1 + "/" + to_print_f1 + " ")
										
									# if (to_print_f2 != ""):
										# output_obj.write(to_print_f2 + "/" + to_print_f2 + " ")
										
									# if (to_print_f3 != ""):
										# output_obj.write(to_print_f3 + "/" + to_print_f3)
										
			
									# output_obj.write('\n')
										
								#printw(output_obj, f"f {f1}/{f1} {f2}/{f2} {f3}/{f3}")
								#printw(output_obj, f"f {f1}/{f1}/{f1} {f2}/{f2}/{f2} {f3}/{f3}/{f3}")
							
				#if (fc_1 == 73084):
				#	break
				
							#f1_r = struct.unpack("<H",file.read(2))[0]
							#f2_r = struct.unpack("<H",file.read(2))[0]
							#f3_r = struct.unpack("<H",file.read(2))[0]
							#f4_r = struct.unpack("<H",file.read(2))[0]
								
							#f1 = 0
							#f2 = 0
							#f3 = 0
							#f4 = 0
								
							#if (f1_r + 2 < vertices_len):
							#	f1 = f1_r + 1
							#else:
							#	f1 = -1
									
							#if (f2_r + 2 < vertices_len):
							#	f2 = f2_r + 1
							#else:
							#	f2 = -1
									
							#if (f3_r + 2 < vertices_len):
							#	f3 = f3_r + 1
							#else:
							#	f3 = -1
								
							#if (f4_r + 2 < vertices_len):
							#	f4 = f4_r + 1
							#else:
							#	f4 = -1
				